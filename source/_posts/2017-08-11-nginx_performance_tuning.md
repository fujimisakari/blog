title: Nginxパフォーマンスチューニング
date: 2017-08-11 00:00
tags: Nginx

---

MySQLに続いて、Nginxのパフォーマンスチューニングで意識してることをまとめみる。

Nginxを利用した構成では以下のような構成になると思いますが
パフォーマスチューニングするにあって意識することを上げてみる

- クライアントとWebサーバ間のチューニング
- WebサーバとAPPサーバ間のチューニング
- Nginx自体の設定でチューニング





## WebサーバとAPPサーバ間のチューニング

### 通信にはUnixsocketドメインを利用する

WebサーバとAPPサーバ間の通信には、UnixドメインsocketもしくHTTP通信で
データのやりとりを行いますが、Unixドメインsocketの方が圧倒的にパフォーマンスが良いです。
Unixドメインsocket場合は、TCPで一度コネクションはって通信してるので
WebサーバとAPPサーバを接続させる時だけ3ハンドシェイクなど手続きを踏みますが
その後は接続したコネクションからデータのやりとりするだけで済みます。
HTTP通信では、リクエストの度にAPPサーバへ接続をしに行きます。
そして、HTTPはTCPより上位レイヤーな分パケットのデータ量も多く
無駄なオーバヘッドがあります。



Nginxって書いてますが、Webサーバーとして利用してるのがNginxなだけで
フロントエンド側で棚卸してみる

Nginxパフォーマンスチューニング
開発時にMySQLのパフォーマンスで気を付けてることのまとめました。
最近、Goでtreeコマンドを作ってみた。
自分はディレクトリとファイルのツリー構造をREADMEなど仕様上の資料に含めることが多いのですが、
その際に必要とするディレクトリとファイルを`mkdir`、`touch`してから、ツリー構造の先頭に行き
treeコマンドを実行して用意するのが手間だったので作りました。









ワーカーとは


worker_processes
ワーカのプロセス数を指定します
ワーカ数の最適値はCPUのコア数やサービスのアクセスパターンによって異なりますが、
基本的にはCPUのコア数と同じ数にするのが良いとされます。
パラメータにautoを指定することでCPUのコア数を自動検出しコア数と同じ数のワーカープロセスを起動できます。

[書式]
worker_processes プロセス数 | auto;
デフォルト値: 1
コンテキスト: main
解説: ワーカプロセスを指定する


**** worker_rlimit_nofile
通常、プロセスがオープンできるファイルディスクリプタの数には上限が設定されています。
Linuxの場合、上限値のデフォルトは1024個です。
nginxでは、1つのワーカプロセスが同時に数千のコネクションを処理することがあるため、
大量のファイルを配信している場合ファイルディスクリプタが足りなくなってしまうことがあります。
ファイルディスクリプタが足りなくなった場合はnginxのエラーログに「Too many open file」と出力されます。

1プロセスで同時にオープン可能なファイルディスクリプタの数はOS側に設定でも変更可能ですが、
nginxでは、この上限をworker_rlimit_nofileディレクティブで指定できます。

大量の静的ファイルを配信しているサーバで、かつ数千コネクションを同時に処理している場合は、
このディレクティブを指定するようにしましょう

[書式]
worker_rlimit_nofile ワーカプロセスがオープン可能なファイルディスクリプタの数;
デフォルト値: OSに依存
コンテキスト: main
解説: ワーカプロセスが同時にオープン可能なファイルディスクリプタの数を指定する

***** worker_connections
ワーカが処理するコネクション数を指定します。
コネクション数はワーカごとの最大数を指定します。
そのため、ワーカ数が2であれば2 x 512= 1024となり、同時に処理できる最大コネクション数は1024になります。
このコネクション数にはクライアント以外とのコネクション数も含まれている点に注意しましょう。
静的ファイルを配信する場合、数倍の値を指定しても問題なることは少くないでしょう。
コネクション数が足りなくなった場合nginxのエラーログに「worker_connections are not enough」と出力されます。


** 3.4 パフォーマンスに影響する設定
次のディレクティブはほとんどの場合で効果的なので、あらかじめ設定しておくようにしましょう。
*** keepalive_timeout
[書式]
keepalive_timeout タイムアウト時間 [Keep-Aliveヘッダに設定するタイムアウト時間]
デフォルト値: 75s
コンテキスト: http, server, location
解説: nginxに常時接続しているクライアントに対するタイムアウト時間。
      この値を0にすると、クライアントからの常時接続を無効にできます

*** sendfile
[書式]
sendfile on | off;
デフォルト値: off
コンテキスト: http, server, location, location中のif
解説: lsendfile()システムコールを有効/無効にする

sendfileディレクティブを有効にすると、ファイルの読み込みとレスポンス送信にsendfile()システムコールが使用されます。
sendfile()を使用すると、ファイルをオープンしているファイルディスクリプタから直接クライアントに送信するので
効率良くファイルの送信ができます。

*** tcp_nopush
[書式]
tcp_nopush on | off;
デフォルト値: off
コンテキスト: http, server, location
解説: TCP_NOPUSH(LinuxではTCP_CORK)オプションを有効/無効にする

sendfileディレクティブが有効な場合にこのオプションを使用すると
最も大きなパケットサイズでレスポンスヘッダとファイル内容を送信でき、送信するパケット数を最小化できます。
基本的には有効にしておくとよいでしょう。

*** open_file_cache
[書式]
oepn_file_cache off;
open_file_cache max=最大エントリ数 [inactive=有効期間];
デフォルト値: off
コンテキスト: http, server, location
解説: オープンしたファイルのキャッシュを有効/無効にする

有効にすると一度オープンしたファイルの情報を一定期間保存します。
次の情報をキャッシュします。
- ファイルのディスクリプタ、サイズ、更新日時
- ディレクトリが存在するか
- 「ファイルが存在しない」「読み取り権限エラー」といったエラーの情報

maxパラメータにはキャッシュの最大エントリ数、
inactiveパラメータにはキャッシュの最後にアクセスがあった日時から有効期間を指定します。
キャッシュのエントリ数かいっぱいになると利用頻度の低いキャッシュから削除されます

なお、エラー情報をキャッシュするには別途oepn_file_cache_errorsを有効にしておく必要があります。
[書式]
open_file_cache_error on | off;
デフォルト値: off;
コンテキスト: http, server, location
解説: オープンしたファイルのエラー情報のキャッシュを有効/無効にする

*** worker_cpu_affinity
nginxの各ワーカプロセスがどのCPUに割り当てられるかはOSのスケジューラに依存しますが
worker_cpu_affinityディレクティブを利用することで各ワーカプロセスを特定のCPUコアに割り当てることができるようになります。

[書式]
worker_cpu_affinity CPUコアのビットマスク ...;
デフォルト値: なし
コンテキスト: main
解説: ワーカプロセスを特定のCPUコアに割り当てる

通常worker_cpu_affinityディレクティブによってCPUの割り当てを指定する必要性は低いため
CPUリソースが枯渇しつつある環境において、どうしても最高のパフォーマンスが必要になる場合のみ指定しましょう。

*** pcre_jit
[書式]
pcre_jit on | off;
デフォルト値: off
コンテキスト: main
解説: PCREのJIT機能を有効/無効にする

PCREライブラリではバージョン8.20以降でJITコンパイルが使用できます。
pcre_jitディレクティブを指定することで正規表現のJITコンパイルを有効にでき、
正規表現の処理速度を向上させることがきます。
PCREライブラリを動的リンクで使用する場合、PCREのビルド時に--enable-jitオプションを指定する必要があります。



